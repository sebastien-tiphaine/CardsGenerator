<?php

require_once(__DIR__.'/MusicLogic.php');
require_once(__DIR__.'/SvgAdapt.php');

abstract class MusicLogicExt extends MusicLogic{

		// cache of getAllPossiblePhrases result
		protected $_arrPossiblePhrasesCache = array();
		// stack of phrases when repartition have to be done
		protected $_arrPossiblePhrasesStacks = array();

		// extract all scale notes positions from an svg file
		// $strFileName can be a file name of an instance of SvgAdapt
		public function extractNotesOrderFromSvg($strFileName, $strNote = false, $intScaleType = self::MAJOR, $strFromStyleExt = false){

			// getting real type value
			$intScaleType = $this->_filterScaleType($intScaleType);

			// setting default adapter
			$oAdapt = null;
			
			// do we have an SvgAdapt instance as $strFileName
			if($strFileName instanceof SvgAdapt){
				// yes
				$oAdapt = $strFileName;
			}
			else if(!is_string($strFileName) || empty($strFileName) ||
			   !file_exists($strFileName)){
				   // invalid file given
				   $this->_debugMessage('invalid file source : '.$strFileName);
				   // nothing can be extracted
				   return false;
				   
			}
			else{
				// loading svg file
				$oAdapt   = new SvgAdapt($strFileName);
			}

			// getting datas
			$arrDatas = $oAdapt->extractCirclesData();		
			// getting scale notes
			$arrScaleNotes = (is_string($strNote))? $this->getScaleOf($strNote, $intScaleType) : false;

			foreach($arrDatas as $intKey => $arrData){

				// could we extract note degre from circle text
				if(!isset($arrData['text']) || empty($arrData['text']) ||
				   !is_numeric($arrData['text']) || is_string($strFromStyleExt)){
						// do we have a style set with the d value
						// setting default d val
						$intDVal = false;
						
						if(isset($arrData['class']) && is_array($arrData['class'])){
								foreach($arrData['class'] as $strClass){
									
										// setting default regexp
										$strRegExp = 'd([1-9])';
										
										// do we have to update the regexp
										if(is_string($strFromStyleExt)){
											// yes
											$strRegExp.='\-'.$strFromStyleExt.'$'; 	
										}
									
										if(preg_match('/'.$strRegExp.'/', $strClass, $arrMatches)){
											$intDVal = intval($arrMatches[1]);
											break;
										}
								}
						}
						
						// is the d val found
						if(!$intDVal){
							// no
							continue;
						}
						
						// updating text value
						$arrData['text'] = $intDVal;
				}
				
				// converting to usable value
				$intDeg = intval($arrData['text']) - 1;
				
				// inserting note and infos
				
				if(is_array($arrScaleNotes) && isset($arrScaleNotes[$intDeg])) {
					$arrDatas[$intKey]['note'] = $arrScaleNotes[$intDeg];
				}
								
				$arrDatas[$intKey]['deg']      = intval($arrData['text']);
				$arrDatas[$intKey]['orderdeg'] = $intDeg;
			}

			return $arrDatas;
		}
		
		// extract all the position of a single degre $intDeg from the array $arrNotesOrder
		// $arrNotesOrder must be in a format as generated by extractNotesOrderFromSvg
		public function extractAllDegPos($intDeg, $arrNotesOrder){

			if(!is_array($arrNotesOrder)){
				throw new Exception('invalid param given for $arrNotesOrder. Array expected');
			}

			if(!is_numeric($intDeg)){
				throw new Exception('invalid param given for $intDeg. integer expected');
			}
			
			$arrResult = array();
			
			foreach($arrNotesOrder as $intKey => $arrNoteData){
				
				if(!isset($arrNoteData['deg']) || $arrNoteData['deg'] != $intDeg){
					continue;
				}
				
				// inserting current key from main array
				$arrNoteData['initialkey'] = $intKey;
				// adding data to result array
				$arrResult[] = $arrNoteData;
			}
			
			return $arrResult;
		}
		
		// stack a list over another in order to get all mixing possibilities
		protected function _stackItems($arrGroups, $arrItems = false, $arrStack = false){
			
			// do we have an array of groups to stack
			if(is_array($arrGroups) && !$arrItems && !$arrStack){
				// yes
				foreach($arrGroups as $arrGroup){
						$arrStack = $this->_stackItems(false, $arrGroup, $arrStack);
				}
				
				return $arrStack;
			}
			
			// we only have a list of items
			$arrNewStack = array();

			// do we have a list of items with no stack
			if(!is_array($arrStack) || empty($arrStack)){
					// yes
					foreach($arrItems as $mItem){
						$arrNewStack[] = array($mItem);
					}
					return $arrNewStack;
			}
				
			foreach($arrItems as $mItem){
				
				foreach($arrStack as $arrStackItems){
					// adding item to the stack items
					$arrStackItems[] = $mItem;
					// adding new stack to the new stack list
					$arrNewStack[] = $arrStackItems;
				}
			}
			
			return $arrNewStack;	
		}
	
		// secondary function of _orderPhrases used to sort the result array
		protected function _orderPhrasesSortCallBack($arrPhraseA, $arrPhraseB){
			
			if($arrPhraseA['metadata']['ranking'] == $arrPhraseB['metadata']['ranking']){
					return 0;
			}
			
			return ($arrPhraseA['metadata']['ranking'] < $arrPhraseB['metadata']['ranking'])? 1 : -1;
		}
	
		// order phrases from criterias
		protected function _orderPhrases($arrPhrases){
			
			// setting default result array
			$arrFormated = array();
			
			foreach($arrPhrases as $intKey => $arrPhrase){
				
				// setting default array values
				$arrFormated[$intKey] = array(
					'phrase'   => $arrPhrase,
					'metadata' => array(
						'ranking'   => 0,
						'direction' => false,
					),
				);
				
				// setting flags
				$arrPStrings = array();
				
				// applying filters
				foreach($arrPhrase as $intNoteKey => $strNoteData){
						
						if($intNoteKey > 0){
								// -- note spacing
								$intSDiff = $arrPhrase[$intNoteKey-1]['s'] - $strNoteData['s'];
								
								if(in_array(abs($intSDiff), array(2,3))){
									$arrFormated[$intKey]['metadata']['ranking']+= 2;
								}
								else if(abs($intSDiff) == 1){
									$arrFormated[$intKey]['metadata']['ranking']+= 1;
								}
								
								// -- /note spacing
								// -- note direction
								$intSDir = (($intSDiff < 0)? -1 : 1);
								
								if(!is_numeric($arrFormated[$intKey]['metadata']['direction'])){
									$arrFormated[$intKey]['metadata']['direction'] = $intSDir;
								}
								else if($arrFormated[$intKey]['metadata']['direction'] == $intSDir){
											$arrFormated[$intKey]['metadata']['ranking']+= 2;
								}
								else{
									$arrFormated[$intKey]['metadata']['direction'] = 0;
								}
								// -- /note direction
								
						}
						
						// -- diff string
						if(!in_array($strNoteData['s'], $arrPStrings)){
								// adding string
								$arrPStrings[] = $strNoteData['s'];
								// updating ranking
								$arrFormated[$intKey]['metadata']['ranking']+= 1;
						}
						else{
							// updating ranking
							$arrFormated[$intKey]['metadata']['ranking']-= 1;
						}
						// -- /diff string			
				}
			}
			
			// sort array
			usort($arrFormated, array($this, '_orderPhrasesSortCallBack'));
			// returning formated datas
			return $arrFormated;
			
		}
	
		// add $intStackLen phrases into each stack of the stack list $arrStacks
		// if $arrStacks is set to an integer, the stack will be built
		protected function _addToPhrasesStack($arrPhrases, $arrStacks = false, $intStackLen = 2){
			
			// do we have to build the stacks list
			if(is_numeric($arrStacks)){
				// yes
				$arrStacks = array_fill(0, $arrStacks, array());
			}
			
			// ensure stacks to be an array
			if(!is_array($arrStacks)){
					$arrStacks = array(array());
			}

			// getting arrays len
			$intCountPhrases = count($arrPhrases);
			$intCountStacks  = count($arrStacks);

			// do we have less phrases than stack list
			if($intCountPhrases < $intCountStacks){
				// yes
				$arrOddPhrases  = array_filter($arrPhrases, function($k){ return($k & 1);}, ARRAY_FILTER_USE_KEY);
				$arrEvenPhrases = array_filter($arrPhrases, function($k){ return(!($k & 1));}, ARRAY_FILTER_USE_KEY);
				
				$arrSup = array();
				$intPassCount = 1;
				
				// adding phrases to sup array until the count of stack is reached
				while(count($arrSup) < $intCountStacks - $intCountPhrases){
		
					// on odd passes 
					if($intPassCount & 1){
						$arrSup = array_merge($arrSup, $arrEvenPhrases);
					}
					else{
						$arrSup = array_merge($arrSup, $arrOddPhrases);
					}
					
					$intPassCount++;	
				}
				
				// updating phrases list
				$arrPhrases = array_merge($arrPhrases, array_slice($arrSup, 0, ($intCountStacks - $intCountPhrases)));
			}

			// init counter
			$intPassCount = 0;

			// setting default check count
			$intCheckCount = $intStackLen;

			if(count($arrPhrases) < $intStackLen){
				$intCheckCount = count($arrPhrases);
			}
			
			while(count($arrStacks[$intCountStacks-1]) < $intCheckCount){

				// init phrases stack
				$arrPhrasesStack = $arrPhrases;
				
				// do we have to change the stack
				if($intPassCount > 0){
					// yes
					$arrPhrasesStack = array_merge(array_slice($arrPhrases, $intPassCount), array_slice($arrPhrases, 0, $intPassCount)); 
				}
			
				// adding item to each stack
				foreach($arrStacks as $intKey => $arrStack){
						// adding one more item to the stack
						// extracting phrase
						$arrPhrase = array_shift($arrPhrasesStack);
			
						// loop until we find a phrase that is not in the stack
						while(in_array($arrPhrase, $arrStack) && (count($arrStack) < $intCheckCount)){

							// do we have to re-init phrases stack
							if(count($arrPhrasesStack) < count($arrStack)){
									// yes
									$arrPhrasesStack = $arrPhrases;
							}
							else{
								// no. adding item to the end of the stack
								$arrPhrasesStack = array_merge($arrPhrasesStack, array($arrPhrase));
							}

							// adding 
							$arrPhrase = array_shift($arrPhrasesStack);							
						} 
						
						$arrStacks[$intKey] = array_merge($arrStack, array($arrPhrase)); 
				}
				
				$intPassCount++;
			}

			return $arrStacks;
		}
	
	
		// returns an array of all possible guide tone from a scale pos in svg format.
		// - if $intNum is set to false, all phrases will be returned
		// - if $intNum is set to an integer, a stack for each tone will be built with $intNum phrases inside 
		//   and only one stack will be return for one call
		public function getAllPossiblePhrases($strFileName, $intStartDeg, $intEndDeg, $mPassingDeg = false, $intNum = false, $strNote = false, $intScaleType = self::MAJOR, $intMoveStackPointer = true){

				// extracting args without the last item
				$arrFuncArgs = func_get_args();
				array_pop($arrFuncArgs);

				// getting real type value
				$intScaleType = $this->_filterScaleType($intScaleType);

				// do we have an SvgAdapt as filename
				if($strFileName instanceof SvgAdapt){
					// yes
					// updating args lists in order to get the right file name
					$arrFuncArgs[0] = $strFileName->getFileName();
				}
				
				// setting ident key for caching and stack
				$strIdentKey = md5(serialize($arrFuncArgs).$this->_intGeneratingTotalToneNumber);
		
				// is the stack set
				if(isset($this->_arrPossiblePhrasesStacks[$strIdentKey]) && !empty($this->_arrPossiblePhrasesStacks[$strIdentKey])){
					// yes
					// returning phrases
					//return array_shift($this->_arrPossiblePhrasesStacks[$strIdentKey]);

					// do we have to move the pointer
					if($intMoveStackPointer){
						// yes
						// setting pointer to the next one
						if(!next($this->_arrPossiblePhrasesStacks[$strIdentKey])){
							// we have to reset the pointer
							reset($this->_arrPossiblePhrasesStacks[$strIdentKey]);
						}
					}

					// extracting current phrase
					return current($this->_arrPossiblePhrasesStacks[$strIdentKey]);
				}
		
				// setting default result array
				$arrPossibilities = array();
		
				// checking if we have a cache
				if(!isset($this->_arrPossiblePhrasesCache[$strIdentKey])){
					// no
				
					// ensure $mPassingDeg to be an array if a string is given
					if(is_numeric($mPassingDeg) && !empty($mPassingDeg)){
							$mPassingDeg = array($mPassingDeg);
					}
					
					// ensure degres to be usable
					$intStartDeg = intval($intStartDeg);
					$intEndDeg   = intval($intEndDeg);
					
					// extracting note from scale schema
					$arrNotesOrder = $this->extractNotesOrderFromSvg($strFileName, $strNote, $intScaleType);

					// getting list of possible startings notes
					$arrStarts = $this->extractAllDegPos($intStartDeg, $arrNotesOrder);
					$arrEnds   = $this->extractAllDegPos($intEndDeg, $arrNotesOrder);

					// setting default passing list
					$arrPassing = array();

					if(is_array($mPassingDeg) && !empty($mPassingDeg)){

						foreach($mPassingDeg as $intPassingDeg){
							$arrPassing[] = $this->extractAllDegPos($intPassingDeg, $arrNotesOrder);
						}
					}

					// mixing all possibilities
					$arrPossibilities = $this->_stackItems(array_merge(array($arrStarts), $arrPassing, array($arrEnds)));
					// ordering
					$arrPossibilities = $this->_orderPhrases($arrPossibilities);
					// setting cache
					$this->_arrPossiblePhrasesCache[$strIdentKey] = $arrPossibilities;
				}
				else{
					// extracting data from cache
					$arrPossibilities = $this->_arrPossiblePhrasesCache[$strIdentKey];	
				}
				
				// do we have to return all phrases
				if($intNum === false || !$this->_intGeneratingCards){
					// yes
					return $arrPossibilities;
				}

				// ok we have to build a stack for each tone
				$this->_arrPossiblePhrasesStacks[$strIdentKey] = $this->_addToPhrasesStack($arrPossibilities, $this->_intGeneratingTotalToneNumber, $intNum);

				// ensure the pointer to be at the start
				reset($this->_arrPossiblePhrasesStacks[$strIdentKey]);

				// extracting current phrase
				return current($this->_arrPossiblePhrasesStacks[$strIdentKey]);

				// returning phrases for the current call
				//return array_shift($this->_arrPossiblePhrasesStacks[$strIdentKey]);	
		}
		
		// ----- Image generate -------------
		
		// method used to auto defines the params of setNeckPosNum
		public function defineNeckPosFromSvg($strFileName, $strNote, $intScaleType = self::MAJOR, $strFromStyleExt = false){
		
				// getting real type value
				$intScaleType = $this->_filterScaleType($intScaleType);
		
				// getting note order
				$arrNoteOrder = $this->extractNotesOrderFromSvg($strFileName, $strNote, $intScaleType, $strFromStyleExt);
				
				// setting default root scale note pos
				$intRootString = false;
				$intRootFret   = false;
				
				foreach($arrNoteOrder as $arrNote){
						// is the degree defined
						if(!isset($arrNote['deg']) || empty($arrNote['deg'])){
								// no
								continue;
						}
						
						// do we have the required deg
						if(intval($arrNote['deg']) != 1){
							// no
							continue;
						}
						
						if(!$intRootString && !$intRootFret){
							// setting values
							$intRootString = intval($arrNote['s']);
							$intRootFret   = intval($arrNote['f']);
							continue;
						}
							
						if(intval($arrNote['s']) > $intRootString){
							// changing values
							$intRootString = intval($arrNote['s']);
							$intRootFret   = intval($arrNote['f']);
						}
				}
		
				// setting defult result array
				$arrResult = array(
					'strNum'     => 'nf', 
					'intFretPos' => 1
				);
		
				// do we have the root note found
				if(!$intRootString && !$intRootFret){
					// no
					return $arrResult;
				}
		
				// getting all the real pos of the root note		
				$arrFrets = $this->getFretNumberForNote($strNote, $intRootString, true);
				// setting default value
				$intFret = intval($arrFrets[0]);
				// looking for an acceptable value
				foreach($arrFrets as $intFretNum){
					$intFretNum = intval($intFretNum);
					
					if($intFretNum >= $intRootFret){
						$intFret = $intFretNum;
						break;
					}
				}
		
				// setting defult result array
				$arrResult['strNum'] = $intFret;
		
				// is the root note placed on the first fret
				if($intRootFret == 1){
					// yes
					return $arrResult;
				}
		
				// no
				// do we have some notes placed on frets before the root note
				$intFirstFretUsed = $intRootFret;
				
				foreach($arrNoteOrder as $arrNote){
					if(intval($arrNote['f']) < $intFirstFretUsed){
						$intFirstFretUsed = intval($arrNote['f']);
					}
				}
				
				// setting pos of the indication on the diagram
				$arrResult['intFretPos'] = $intFirstFretUsed;
				
				// do we have a first fret equal to the one of the root note
				if($intFirstFretUsed == $intRootFret){
					// yes. It mean that the root note is not on the first fret.
					//      case of chords diagrams
					return $arrResult;
				}
				
				// values are different so we have to change the displayed number
				$arrResult['strNum'] = $intFret - ($intRootFret - $intFirstFretUsed);
				// done
				return $arrResult;	
		}
} 
